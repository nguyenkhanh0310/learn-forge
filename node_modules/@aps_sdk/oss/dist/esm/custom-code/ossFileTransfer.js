var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ObjectsApi } from "../api";
import { DownloadStatus } from "../model";
import { OssApiError } from "../base";
import { createRequestFunctionOss } from "../common";
import { createWriteStream } from "fs";
import { PassThrough } from "stream";
class Constants {
}
Constants.MaxRetry = 5;
Constants.ChunkSize = 5 * 1024 * 1024;
Constants.BatchSize = 25;
export class OSSFileTransfer {
    constructor(configuration, sdkmanager, authenticationProvider) {
        this.accessTokenExpiredMessage = 'Access token provided is invalid or expired.';
        this.forbiddenMessage = '403 (Forbidden)';
        this.sdkManager = sdkmanager;
        this.configuration = configuration;
        this.objectApi = new ObjectsApi(this.sdkManager);
        this.maxChunkCountAllowed = this.configuration.getMaxChunkCountAllowed();
        this.maxRetryOnUrlExpiry = this.configuration.getMaxRetryOnUrlExpiry();
        this.maxRetryOnTokenExpiry = this.configuration.getMaxRetryOnTokenExpiry();
        // this._authentication = authentication;
        this.logger = this.sdkManager.logger;
        if (authenticationProvider) {
            this.authProvider = authenticationProvider;
        }
    }
    upload(bucketKey_1, objectKey_1, sourceToUpload_1, accessToken_1, cancellationToken_1) {
        return __awaiter(this, arguments, void 0, function* (bucketKey, objectKey, sourceToUpload, accessToken, cancellationToken, requestIdPrefix = '', onProgress) {
            const requestId = yield this.handleRequestId(requestIdPrefix, bucketKey, objectKey);
            const retryCount = this.configuration.getRetryCount();
            this.logger.logDebug(`${requestId} Config retry setting was: ${retryCount}`);
            yield this.validateFileSize(requestId, sourceToUpload);
            onProgress === null || onProgress === void 0 ? void 0 : onProgress(1);
            var numberOfChunks = this.calculateNumberOfChunks(sourceToUpload.length);
            var chunksUploaded = 0;
            var start = 0;
            var uploadUrls = [];
            var uploadKey = null;
            while (chunksUploaded < numberOfChunks) {
                this.throwIfCancellationRequested(cancellationToken, requestId);
                var attempts = 0;
                var end = Math.min(start + Constants.ChunkSize, sourceToUpload.length);
                var fileBuffer = this.readFileBytes(sourceToUpload, start, end);
                var retryUrlExpiryCount = 0;
                while (true) {
                    this.throwIfCancellationRequested(cancellationToken, requestId);
                    attempts++;
                    this.logger.logInfo(`${requestId} Uploading part ${chunksUploaded}, attempt ${attempts}`);
                    if (uploadUrls.length == 0) {
                        retryUrlExpiryCount++;
                        var [uploadUrlsResponse, currentAccessToken] = yield this.getUploadUrlsWithRetry(bucketKey, objectKey, numberOfChunks, chunksUploaded, uploadKey, accessToken, requestId);
                        uploadKey = uploadUrlsResponse.uploadKey;
                        uploadUrls = uploadUrlsResponse.urls;
                        accessToken = currentAccessToken;
                    }
                    var currentUrl = uploadUrls.shift();
                    try {
                        this.throwIfCancellationRequested(cancellationToken, requestId);
                        var responseBuffer = yield this.uploadToURL(currentUrl, fileBuffer, accessToken, requestId);
                        var statusCode = responseBuffer.status;
                        if (statusCode === 403 && retryUrlExpiryCount === this.maxRetryOnUrlExpiry) {
                            this.logger.logInfo(`${requestId} URL can not be refreshed.`);
                            throw new OssApiError(`${statusCode} URL can not be refreshed`);
                        }
                        if (statusCode == 403) {
                            this.logger.logInfo(`${requestId} 403, refreshing urls, attempt: ${retryUrlExpiryCount}`);
                            uploadUrls = [];
                            continue;
                        }
                        break;
                    }
                    catch (error) {
                        this.logger.logError(error.message);
                        if (attempts == Constants.MaxRetry) {
                            this.logger.logError(`${requestId} Couldn't upload chunk after max retry of ${Constants.MaxRetry}`);
                            throw new OssApiError(`${requestId} ${error.Message}`);
                        }
                    }
                }
                chunksUploaded++;
                start = end;
                var percentCompleted = (chunksUploaded / numberOfChunks) * 100;
                onProgress === null || onProgress === void 0 ? void 0 : onProgress(percentCompleted);
                this.logger.logInfo(`${requestId} Number of chunks uploaded : ${chunksUploaded}`);
            }
            var completeResponse = yield this.objectApi.completeSignedS3Upload(accessToken, bucketKey, objectKey, "application/json", {
                uploadKey: uploadKey
            });
            onProgress === null || onProgress === void 0 ? void 0 : onProgress(100);
            return completeResponse;
        });
    }
    uploadToURL(currentUrl, fileChunk, accessToken, requestId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const localVarHeaderParameter = {};
            localVarHeaderParameter['x-ads-request-id'] = requestId;
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter);
            localVarRequestOptions.data = fileChunk;
            const localVarAxiosArgs = {
                url: currentUrl,
                options: localVarRequestOptions
            };
            const request = createRequestFunctionOss(localVarAxiosArgs, this.sdkManager);
            const response = yield request();
            return response;
        });
    }
    download(bucketKey, objectKey, accessToken, filePath, cancellationToken, requestIdPrefix, onProgress) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestId = yield this.handleRequestId(requestIdPrefix, bucketKey, objectKey);
            onProgress === null || onProgress === void 0 ? void 0 : onProgress(1);
            const response = yield this.getS3SignedDownloadUrlWithRetry(bucketKey, objectKey, accessToken, requestId);
            const fileSize = response.size;
            const numberOfChunks = this.calculateNumberOfChunks(fileSize);
            let partsDownloaded = 0;
            let start = 0;
            let outStream = new PassThrough();
            outStream.setMaxListeners(numberOfChunks + 1);
            let fileStream;
            if (filePath) {
                fileStream = createWriteStream(filePath, { flags: 'a' });
            }
            try {
                while (partsDownloaded < numberOfChunks) {
                    this.logger.logInfo(`${requestId} Downloading part: ${partsDownloaded}`);
                    const end = Math.min((partsDownloaded + 1) * Constants.ChunkSize, fileSize);
                    if (start == end) {
                        break;
                    }
                    let attemptCount = 0;
                    while (attemptCount < this.maxRetryOnUrlExpiry) {
                        try {
                            attemptCount++;
                            this.logger.logInfo(`${requestId} Downloading file range: ${start}-${end}`);
                            const partStream = yield this.writeToFileStreamFromUrl(response.url, start, end, requestId);
                            if (filePath) {
                                partStream.pipe(fileStream, { end: false });
                            }
                            else
                                partStream.pipe(outStream, { end: false });
                            start = end + 1;
                            partsDownloaded++;
                            const percentCompleted = Math.floor((partsDownloaded / numberOfChunks) * 100);
                            onProgress === null || onProgress === void 0 ? void 0 : onProgress(percentCompleted);
                            break;
                        }
                        catch (error) {
                            this.logger.logError(`${requestId} Error downloading part: ${partsDownloaded}. Attempt ${attemptCount}/${this.maxRetryOnUrlExpiry}. Error: ${error}`);
                        }
                    }
                }
            }
            catch (error) {
                this.logger.logError(`${requestId} Error downloading file: ${error}`);
            }
            if (!filePath) {
                return outStream;
            }
        });
    }
    isFileSizeAllowed(file) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileSize = file.length;
            const numberOfChunks = this.calculateNumberOfChunks(fileSize);
            if (numberOfChunks > this.maxChunkCountAllowed) {
                return false;
            }
            return true;
        });
    }
    readFileBytes(file, start, end) {
        const fileReader = file.subarray(start, end);
        return fileReader;
    }
    getUploadUrlsWithRetry(bucketKey, objectKey, numberOfChunks, chunksUploaded, uploadKey, accessToken, requestId) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            var attemptcount = 0;
            var parts = (Math.min(numberOfChunks - chunksUploaded, Constants.BatchSize));
            var firstPart = chunksUploaded + 1;
            do {
                this.logger.logInfo(`${requestId} Refreshing URL attempt:${attemptcount}.`);
                try {
                    var response = yield this.objectApi.signedS3Upload(accessToken, bucketKey, objectKey, parts, firstPart, uploadKey);
                    return ([response.content, accessToken]);
                }
                catch (e) {
                    if (e.message.includes(this.accessTokenExpiredMessage)) {
                        attemptcount++;
                        //Yet to be implemented
                        // accessToken = this.authentication.getUpdatedAccessToken();
                        accessToken = yield ((_a = this.authProvider) === null || _a === void 0 ? void 0 : _a.getAccessToken());
                        this.logger.logInfo(`${requestId} Token expired. Trying to refresh`);
                    }
                    else {
                        this.logger.logInfo(`${requestId} Error: ${e.message}`);
                        throw e;
                    }
                }
            } while (attemptcount < this.maxRetryOnTokenExpiry);
            throw new OssApiError(`${requestId} Error: Fail getting upload urls after maximum retry`);
        });
    }
    calculateNumberOfChunks(fileSize) {
        if (fileSize == 0) {
            return 1;
        }
        var numberOfChunks = Math.trunc(fileSize / Constants.ChunkSize);
        if (fileSize % Constants.ChunkSize != 0) {
            numberOfChunks++;
        }
        return numberOfChunks;
    }
    validateFileSize(requestId, sourceToUpload) {
        return __awaiter(this, void 0, void 0, function* () {
            var sizeAllowed = yield this.isFileSizeAllowed(sourceToUpload);
            if (!sizeAllowed) {
                throw new OssApiError(`${requestId} File size too big to upload. Currently max file size allowed is ${Number(this.maxChunkCountAllowed) * Number(Constants.ChunkSize)} bytes`);
            }
        });
    }
    handleRequestId(parentRequestId, bucketKey, objectKey) {
        return __awaiter(this, void 0, void 0, function* () {
            var requestId = parentRequestId && parentRequestId.trim() != "" ? parentRequestId : String(Math.random());
            requestId = requestId + ":" + this.GenerateSdkRequestId(bucketKey, objectKey);
            return requestId;
        });
    }
    GenerateSdkRequestId(bucketKey, objectKey) {
        return bucketKey + "/" + objectKey;
    }
    getS3SignedDownloadUrlWithRetry(bucketKey, objectKey, accessToken, requestId) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            var attemptCount = 0;
            do {
                this.logger.logInfo(`${requestId} Get signed URL to download directly from S3 attempt: ${attemptCount}`);
                try {
                    var objectStatusEnumString = DownloadStatus.Complete;
                    var response = yield this.objectApi.signedS3Download(accessToken, bucketKey, objectKey, requestId);
                    if (response.content.status != objectStatusEnumString) {
                        this.logger.logError(`${requestId} File not available for download yet.`);
                        throw new OssApiError(`${requestId} File not available for download yet.`);
                    }
                    return response.content;
                }
                catch (error) {
                    if (error.message.includes(this.accessTokenExpiredMessage)) {
                        attemptCount++;
                        //Yet to be implemented
                        // accessToken = this.authentication.getUpdatedAccessToken();
                        accessToken = yield ((_a = this.authProvider) === null || _a === void 0 ? void 0 : _a.getAccessToken());
                        this.logger.logInfo(`${requestId} Token expired. Trying to refresh`);
                    }
                    else {
                        this.logger.logError(`${requestId} Error: ${error.message}`);
                        throw error;
                    }
                }
            } while (attemptCount < this.maxRetryOnTokenExpiry);
            throw new OssApiError(`${requestId} Error: Fail getting upload urls after maximum retry`);
        });
    }
    validateProjectScopeName(requestId, projectScope) {
        const scopeRegex = /^([a-zA-Z0-9.\\-_]{3,50}(,?)){1,20}$/;
        if (!(projectScope === '' || scopeRegex.test(projectScope))) {
            throw new OssApiError(`${requestId} Parameter 'projectScope' doesn't pass regex test - user must submit a valid scope.`);
        }
    }
    throwIfCancellationRequested(cancellationToken, requestId) {
        if (cancellationToken.signal.aborted) {
            this.logger.logInfo("${requestId} Cancellation requested.");
            cancellationToken.signal.throwIfAborted();
        }
    }
    writeToFileStreamFromUrl(Url, start, end, requestId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const localVarHeaderParameter = {};
            const rangeHeaderValue = `bytes=${start}-${end}`;
            localVarHeaderParameter['x-ads-request-id'] = requestId;
            localVarHeaderParameter['Range'] = String(rangeHeaderValue);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter);
            localVarRequestOptions.responseType = "stream";
            const localVarAxiosArgs = {
                url: Url,
                options: localVarRequestOptions
            };
            const request = createRequestFunctionOss(localVarAxiosArgs, this.sdkManager);
            const response = yield request();
            this.logger.logInfo(`${requestId} Successfully downloaded file range: ${start} - ${end}`);
            return response.data;
        });
    }
}
